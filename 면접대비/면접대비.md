#### 면접대비 내가 한 프로젝트 내용 정리 및 기술에 관한 내용정리

## Spring 

### IoC(제어역전)
> 제어권을 개발자가 아닌 프레임워크가 가지는 것
>
> 개발자는 객체 생성이나 관련된 코드를 제공하지 않고 정의 방법을 사용하여 코드를 정의한다.

### DI(의존관계 주입)
> DI는 외부에서 객체 간의 관계(의존성)를 결정해 주는데 즉, 객체를 직접 생성하는 것이 아니라 외부에서 생성 후 주입시켜 주는 방식이라 

### DI 의존관계 주입 방법
- 생성자 주입 
- 필드주입 (@Autowired)
- Setter를 통해 주입

### AOP 프로그래밍(관점지향 프로그래밍)
> 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어보고 그 관점을 기준으로 모듈화.
>
> 부가 기능을 핵심 기능에서 분리해 한 곳에서 관리하도록 하고, 이 부가 기능을 어디에 적용할 것인지 선택하는 기능을 합한 하나의 모듈

## JPA
> java 에서 사용하는 ORM의 표준

### ORM 이란
> Object Relation Mapping 으로 객체 지향적 언어의 객체와 RDB의 테이블을 자동으로 매핑해 주는 기술

### ORM의 장점
> - 개발자가 SQL을 직접 작성하지 않아도 된다.
> - 코드 가독성, 재사용성, 유지보수성이 좋아지고
> - 특히 특정 DB에 관한 종속성이 줄어든다.

### 영속성 컨텍스트란
> - 데이터를 영구 보관하는 환경
> - 애플리케이션과 DB 사이에 객체를 보관하는 가상 데이터베이스의 역할
> - EntityManager가 생성될 때 1대1로 영속성 컨텍스트가 생성된다.
> - 영속성 컨테스트는 트랜잭션의 단위로 동작한다.
> - 정리 : 트랜잭션 시작 -> EntityManger 생성 -> 영속성 컨텍스트 생성 -> 트랜잭션 종료 -> EntityManger, 영속성 컨텍스트 종료 

### 영속성 컨텍스트 장점
> - 1차 캐시
> - 동일성 보장
> - 쓰기 지연
> - 변경 감지
> - 지연 로딩

## DBMS

### 데이터베이스 트랜잭션이란?
> 데이터 베이스 상태를 변화시키기 위해 수행하는 작업 단위

### 데이터베이스 ACID
> - 원자성(Atomicity) : 트랜잭션은 일부만 성공한 상태일 수 없다. (전부 성공 or 전부 실패 상태가 되어야함)
> - 일관성(Consistency) : 트랜잭션 처리 전과 처리 후 데이터의 모순이 없어야 한다.
> - 독립성(Isolation) : 다른 트랜잭션에 끼어들지 못한다.
> - 영속성(Durability) : 트랜잭션의 결과는 영원히 반영되어야 한다.

### 데이터베이스 격리 수준
> - read uncommited : dirty read 발생 -> 다른 트랜잭션의 commit 하지 않는 정보를 읽을 수 있음
> - read commited : Non-repatable read 발생 -> 트랜잭션 내에서 같은 행을 반복해서 읽었을 떄 그 행을 수정하거나 결과가 바뀌는 현상
> - repetable read : phantom read 발생 -> 트랜잭션의 순서가 적은 번호에서 변경한 것만 보인다.
>                    -> 그래서 msyql에서는 검색 조건 범위에 해당하는 행에 잠금을 걸어 방지
> - serializable : 없음 -> 이전 트랜잭션이 실행되어야 다음 트랜잭션이 실행됨.

> 뒤로 갈 수록 동시성이 떨어짐

### NoSql과의 차이점
> RDBMS는 정규화 된 규격과 관계가 있음. 하지만 Nosql은 정규화된 규격이 없음
>
> 그래서 Nosql은 확장성이 뛰어남### 면접대비 내가 한 프로젝트 내용 정리 및 기술에 관한 내용정리

## JPA
> java 에서 사용하는 ORM의 표준

### ORM 이란
> Object Relation Mapping 으로 객체 지향적 언어의 객체와 RDB의 테이블을 자동으로 매핑해 주는 기술

### ORM의 장점
> - 개발자가 SQL을 직접 작성하지 않아도 된다.
> - 코드 가독성, 재사용성, 유지보수성이 좋아지고
> - 특히 특정 DB에 관한 종속성이 줄어든다.

### 영속성 컨텍스트란
> - 데이터를 영구 보관하는 환경
> - 애플리케이션과 DB 사이에 객체를 보관하는 가상 데이터베이스의 역할
> - EntityManager가 생성될 때 1대1로 영속성 컨텍스트가 생성된다.
> - 영속성 컨테스트는 트랜잭션의 단위로 동작한다.
> - 정리 : 트랜잭션 시작 -> EntityManger 생성 -> 영속성 컨텍스트 생성 -> 트랜잭션 종료 -> EntityManger, 영속성 컨텍스트 종료 

### 영속성 컨텍스트 장점
> - 1차 캐시
> - 동일성 보장
> - 쓰기 지연
> - 변경 감지
> - 지연 로딩

### n+1 문제?
> 연관관계가 설정된 엔티티를 조회 했을 때, 조회된 엔티티의 개수(N번) 만큼 엔티티를 조회하는 추가적인 쿼리가 발생하는 문제

### n+1 문제 해결법
> - fetch join 사용 : 한번의 쿼리로 연관된 엔티티를 함께 조회하는 방법
> - Entity Graph 사용

## DBMS

### 데이터베이스 트랜잭션이란?
> 데이터 베이스 상태를 변화시키기 위해 수행하는 작업 단위

### 데이터베이스 ACID
> - 원자성(Atomicity) : 트랜잭션은 일부만 성공한 상태일 수 없다. (전부 성공 or 전부 실패 상태가 되어야함)
> - 일관성(Consistency) : 트랜잭션 처리 전과 처리 후 데이터의 모순이 없어야 한다.
> - 독립성(Isolation) : 다른 트랜잭션에 끼어들지 못한다.
> - 영속성(Durability) : 트랜잭션의 결과는 영원히 반영되어야 한다.

### 데이터베이스 격리 수준
> - read uncommited : dirty read 발생 -> 다른 트랜잭션의 commit 하지 않는 정보를 읽을 수 있음
> - read commited : Non-repatable read 발생 -> 트랜잭션 내에서 같은 행을 반복해서 읽었을 떄 그 행을 수정하거나 결과가 바뀌는 현상
> - repetable read : phantom read 발생 -> 트랜잭션의 순서가 적은 번호에서 변경한 것만 보인다.
>                    -> 그래서 msyql에서는 검색 조건 범위에 해당하는 행에 잠금을 걸어 방지
> - serializable : 없음 -> 이전 트랜잭션이 실행되어야 다음 트랜잭션이 실행됨.

> 뒤로 갈 수록 동시성이 떨어짐

### NoSql과의 차이점
> RDBMS는 정해진 스키마에 따라 데이터를 저장 함. 하지만 Nosql은 정해진 스키마가 없음.
>
> 그래서 Nosql은 데이터 구조를 확장성이 뛰어남

## MSA란

### MSA 은 무엇이며 어떤 이점이 있나?
> Microservice Architecture로 하나의 어플리케이션을 여러개의 작은 어플리케이션으로 나누어 만든 아키텍처
>
> 필요 서비스 단위로 나눠 서비스 별로 독립적인 배포가 가능하다. 확장성이 좋음

### 모놀리식 아키텍처란?
> 모놀리식 아키텍처는 모든 소프트웨어 구성요소가 한 프로젝트에 통합되어있는 형태

### 그래서 어떨때 어떤걸 사용하는게 좋은가?
> 모놀리식으로 개발할 경우 초기단계에서 부터 빠르게 프로토타입을 개발할 수 있다. 그러나 유지관리 및 확장이 어려우진다.
>
> MSA 경우 초기 개발및 통신에 시간이 소요된다. 서비스간에 독립성으로 확장성과 유연성이 높아진다.


