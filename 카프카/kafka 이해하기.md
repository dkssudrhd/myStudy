## Kafka란?
> 분산 이벤트 스트리밍 플랫폼

## Kafka 기본 구조
![image](https://github.com/user-attachments/assets/d0554e28-d1f4-46ce-a7f5-90b9897e1830)

- 카프카 클러스터
  - 메세지를 저장하는 저장소
  - 하나의 카프카 클러스터는 여러개의 브로커로 구성
    - 브로커는 각각의 서버
    - 브로커들은 메시지를 나눠서 저장, 이중화, 장애 발생시 대체 등의 역할을 함
  - 데이터를 이동하는데 필요한 핵심 역할을 맡음
    
- 주키퍼 클러스터
  - 카프카 클러스터를 관리하는 용도
  - 카프카 클러스터와 관련된 정보를 기록

- 프로듀서
  - 메세지를 카프카에 넣음
 
- 컨슈머
  - 메세지를 카프카에서 읽음

## 토픽과 파티션

![image](https://github.com/user-attachments/assets/b779b235-4ed9-42f7-b057-c0fa377481dc)

- 토픽
  - 메세지를 구분하는 단위(파일시스템의 폴더와 유사)
  - 한개의 토픽은 한 개 이상의 파티션으로 구성
- 파티션
   - 메시지를 저장하는 물리적인 파일

> 프로듀서는 메시지를 저장할 때 '어떤 토픽에 저장해줘'라고 요청을 보냄 
> 
> 컨슈머는 '어떤 토픽에서 메시지를 읽어올래'라고 함


## 파티션과 오프셋, 메시지 순서
- 파티션은 추가만 가능한(append-only) 파일임
  - 각 메시지 저장 위치를 오프셋(offset)이라고 함
  - 프로듀서가 넣은 메시지는 파티션의 맨 뒤에 추가
  - 컨슈머는 오프셋 기준으로 메시지를 순서대로 읽음
  - 메시지는 삭제되지 않음(설정에 따라 일정 시간이 지난 뒤 삭제)

![image](https://github.com/user-attachments/assets/6f2aaffe-4cc7-4330-88f8-32734f7f67d2)

## 여러 파티션과 프로듀서
- 프로듀서는 라운드로빈 또는 키로 파티션 선택
  - 같은 키를 갖는 메시지는 같은 파티션에 저장 -> 같은 키는 순서 유지

- 컨슈머는 컨슈머그룹에 속함
- 한 개 파티션은 컨슈머그룹의 한 개 컨슈머만 연결 가능
  - 즉 컨슈머그룹에 속한 컨슈머들은 한 파티션을 공유할 수 없음
  - 한 컨슈머그룹 기준으로 파티션의 메시지는 순서대로 처리

![image](https://github.com/user-attachments/assets/ad698898-d1b8-4a83-b419-5a984156db33)

## 카프카 성능
- 파티션 파일은 OS 페이지캐시 사용
  - 파티션에 대한 파일 IO를 메모리에서 처리
  - 서버에서 페이지캐시를 카프카만 사용해야 성능에 유리

- Zero Copy
  - 디스크 버퍼에서 네트워크 버퍼로 직접 데이터 복사

- 컨슈머 추적을 위해 브로커가 하는 일이 비교적 단순
  - 메시지 필터, 메시지 재전송과 같은 일은 브로커가 하지 않음
      - 프로듀서, 컨슈머가 직접해야 함
  - 브로커는 컨슈머와 파티션 간 매핑 관리

- 묶어서 보내기, 묶어서 받기 (batch)
  - 프로듀서 : 일정 크기 만큼 메시지를 모아서 전송 가능
  - 컨슈머 : 최소 크기 만큼 메시지를 모아서 조회 가능
  - 낱개 처리보다 처리량 증가

- 처리량 증대(확장)가 쉬움
  - 1개 장비의 용량 한계 -> 브로커 추가, 파티션 추가
  - 컨슈머가 느림 -> 컨슈머 추가 (+파티션 추가)

![image](https://github.com/user-attachments/assets/e839d92a-6511-4c20-8fd1-fc94b886f18f)

## 리플리카 - 복제
- 리플리카 : 파티션의 복제본
  - 복제수 만큼 파티션의 복제본이 각 브로커에 생김

- 리더와 팔로워로 구성
  - 프로듀셔와 컨슈머는 리더를 통해서만 메시지 처리
  - 팔로워는 리더로부터 복제

- 장애 대응
  - 리더가 속한 브로커 장애시 다른 팔로워가 리더가 됨


### 출처
> https://www.youtube.com/watch?v=0Ssx7jJJADI
