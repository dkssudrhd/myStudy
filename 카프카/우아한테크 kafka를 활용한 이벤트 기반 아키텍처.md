## 목차
- 이벤트 기반 아키텍처를 왜?
- 이벤트의 구성요소
- 이벤트 파이프라인
- 이벤트의 활용사례

## 이벤트 기반 아키텍처
- 요구사항이 점점 증가함 -> 복잡도가 증가됨
- 그래서 시스템을 분리
- 요구사항이 동시 실행되어야 함

### 장점
- 기능을 나누어 정리함

## 이벤트의 구성요소
> 배달의 민족에서는 대상, 행동, 정보, 시간을 사용함

- 대상
  - 식벽자의 정보
- 행동
  - 이미 벌어진 사건임으로 과거형으로 사용
- 정보
  - 행위와 관련된 값들을 표현한다.
  - 행위 외의 값도 추가 가능 하도록 구현
- 시간
  - 행위가 발생한 시간을 표현

### 장점
- 요구사항이 추가 되어도 복잡도에 변화가 없다.
- 따로 상세정보를 조회하지 않아도 됨(이벤트 정보를 통해 보냄)
- 데이터 분석에도 좋음

### 주의할 점
- 이벤트를 무분별하게 추가하면 안됨
- 이벤트의 순서가 중요함

## 이벤트 파이프라인
> 메시지 브로커를 사용해야 함

### Kafka를 선택한 이유
- 순서보장
  - 토픽의 파티션을 통해 Key별로 순서 보장

- 고성능 고가용성
  - 실시간 이벤트를 처리할 고성능 고가용성 제공
  - 하나의 브로커가 문제가 생겨도 다른 브로커에서 처리
  
- 통합 도구
  - Kafka Streams, Kafka Connect 등 다양한 통합도구를 지원
  - 시스템을 개선하거나 확장할 수 있음

- 전담팀 지원
  - 우아한 형제들에서는 따로 팀이 있어서 사용

### Kafka를 도입해도 문제
- 사용하는 이벤트 발행의 이슈가 생길때가 있음 -> 그래서 순서가 변경되기도 함
  - Transactional outbox Pattern 도입
    ![image](https://github.com/user-attachments/assets/cad7f733-223c-4d01-aa69-18ea9bfbb4b7)
    - 데이터베이스의 Transactional 기술을 활용하여 outbox 테이블에 적재하고 Message Relay 가 이벤트 발행을 보장해주는 기법
    - 우선 발행해야 하는 이벤트를 도메인 처리 Transactional과 묶어 outbox 테이블에 저장해준다.(도메인의 상태와 발행해야하는 이벤트간에 일관성을 보장)
    - 그 후 Message Relay가 outbox 테이블에 저장된 이벤트를 순서대로 읽어 발행함으로 이벤트의 순서와 발행을 보장해줌

### Message Relay를 구현할 때 고려한 점
> 오픈 소스 debezium을 사용
>
> 데이터베이스 변경된 사항을 감지하고 타 시스템에게 전송하는 플랫폼임

- 저비용
  - 설정을 통해 Connect 등록/실행 및 모니터링 제공

- 안정성
  - Binary log 를 통한 순서 보장 및 offset을 활용한 발행 보장
  - 발행이 실패하더라도 발행이 실패한 offset부터 읽어서 처리
    
- 처리량
  - Outbox 테이블 파티셔닝을 통한 처리량 증대
    > 파티셔닝이란 테이블의 각 행을 다른 테이블에 분산시키는 것(샤드를 생각하면 됨)
  
  ![image](https://github.com/user-attachments/assets/1a1a51ed-3af1-4df4-857a-2640f1916fec)

## 이벤트 활용사례
- 이벤트 스트림으로 CQRS 적용
  > CQRS란 Command and Query Responsibility Segregation 의 약자로, 데이터 저장소로부터의 읽기와 업데이트 작업을 분리하는 패턴

- 이벤트 스트림으로 데이터 분석 환경 구축
- 이벤트 스트림으로 스트림즈 애플리케이션을 구현
  - 이전에는 배치를 통해 하였지만 데이터베이스에게 부하를 주는 문제가 있었음
  


### 출처
> https://www.youtube.com/watch?v=DY3sUeGu74M
